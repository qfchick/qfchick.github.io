<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法竞赛内容整理</title>
    <link href="/2025/09/30/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
    <url>/2025/09/30/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> f[N];<br><span class="hljs-comment">/*初始化*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        f[i]=i;<br>&#125;<br><span class="hljs-comment">/*路径压缩找x的根*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[x]==x)<br>        <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> f[x]=<span class="hljs-built_in">find</span>(f[x]);<br>&#125;<br><span class="hljs-comment">/*合并x和y所在的树*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    f[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><ul><li><a href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集 - 洛谷</a></li></ul><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> t[N];<br><span class="hljs-comment">/*单点修改（x加上y）*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!x) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">while</span>(x&lt;=n)&#123;<br>        t[x]+=y;<br>        x+=x&amp;(-x);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*区间点查询（1~x的和）*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        res+=t[x];<br>        x-=x&amp;(-x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">/*查询[l,r]和*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(r)-<span class="hljs-built_in">get</span>(l<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><ul><li><a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1 - 洛谷</a></li></ul><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ll a[N<span class="hljs-number">+5</span>],tr[<span class="hljs-number">4</span>*N<span class="hljs-number">+5</span>],lz[<span class="hljs-number">4</span>*N<span class="hljs-number">+5</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span></span>&#123;<br>    tr[p]=tr[p*<span class="hljs-number">2</span>]+tr[p*<span class="hljs-number">2</span><span class="hljs-number">+1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>    lz[p*<span class="hljs-number">2</span>]+=lz[p];<br>    lz[p*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]+=lz[p];<br>    tr[p*<span class="hljs-number">2</span>]+=lz[p]*(mid-l<span class="hljs-number">+1</span>);<br>    tr[p*<span class="hljs-number">2</span><span class="hljs-number">+1</span>]+=lz[p]*(r-mid);<br>    lz[p]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r)&#123;<br>        tr[p]=a[l];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">build</span>(l,mid,p*<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">build</span>(mid<span class="hljs-number">+1</span>,r,p*<span class="hljs-number">2</span><span class="hljs-number">+1</span>);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t,ll k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)&#123;<br>        lz[p]+=k;<br>        tr[p]+=k*(t-s<span class="hljs-number">+1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid=(l+r)/<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">pushdown</span>(p,l,r);<br>    <span class="hljs-keyword">if</span>(s&lt;=mid)<br>        <span class="hljs-built_in">update</span>(p*<span class="hljs-number">2</span>,l,mid,s,t,k);<br>    <span class="hljs-keyword">if</span>(mid&lt;t)<br>        <span class="hljs-built_in">update</span>(p*<span class="hljs-number">2</span><span class="hljs-number">+1</span>,mid<span class="hljs-number">+1</span>,r,s,t,k);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><ul><li><a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1 - 洛谷</a></li></ul><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><h4 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h4><p><strong>字符版</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> t[N][<span class="hljs-number">70</span>],cnt[N],idx;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-keyword">return</span> c-<span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">if</span>(c&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>) <span class="hljs-keyword">return</span> c-<span class="hljs-string">&#x27;A&#x27;</span><span class="hljs-number">+26</span>;<br>    <span class="hljs-keyword">return</span> c-<span class="hljs-string">&#x27;0&#x27;</span><span class="hljs-number">+52</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> l:s)&#123;<br>        <span class="hljs-type">int</span> c=<span class="hljs-built_in">get</span>(l);<br>        <span class="hljs-keyword">if</span>(!t[p][c]) t[p][c]=++idx;<br>        p=t[p][c];<br>        cnt[p]++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> l:s)&#123;<br>        <span class="hljs-type">int</span> c=<span class="hljs-built_in">get</span>(l);<br>        <span class="hljs-keyword">if</span>(!t[p][c]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p=t[p][c];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h4><h5 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h5><p><strong>用途</strong></p><p>求所有点间的最短路</p><p><strong>前置定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> g[N][N];<br></code></pre></td></tr></table></figure><p><strong>算法代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>                <span class="hljs-keyword">if</span>(g[i][j]&gt;g[i][k]+g[k][j])<br>                    g[i][j]=g[i][k]+g[k][j];<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h5><p>前置定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> v,w;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(node x,node y)&#123;<br>        <span class="hljs-keyword">return</span> x.w&gt;y.w;<br>    &#125;<br>&#125;;<br>vector&lt;node&gt; g[N];<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">bool</span> vis[N];<br></code></pre></td></tr></table></figure><p>算法代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    dis[s]=<span class="hljs-number">0</span>;<br>    priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt;&gt; q;<br>    q.<span class="hljs-built_in">push</span>(&#123;s,<span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> u=q.<span class="hljs-built_in">top</span>().v;<br>        q.<span class="hljs-built_in">pop</span>(); <br>        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<br>        vis[u]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [v,w]:g[u])<br>            <span class="hljs-keyword">if</span>(dis[v]&gt;dis[u]+w)<br>                q.<span class="hljs-built_in">push</span>(&#123;v,dis[v]=dis[u]+w&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p><strong>简介</strong></p><p>一个图中可能存在多条相连的边，我们<strong>一定可以从一个图中挑出一些边生成一棵树</strong>。这仅仅是生成一棵树，还未满足最小，<strong>当图中每条边都存在权重时，这时候我们从图中生成一棵树( $n-1$  条边)时,生成这棵树的总代价就是每条边的权重相加之和。</strong></p><h5 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h5><p>我很喜欢的算法，需要并查集实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>&#123;<br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> u=<span class="hljs-built_in">find</span>(p[i].u),v=<span class="hljs-built_in">find</span>(p[i].v);<br>        <span class="hljs-keyword">if</span>(u==v)<br>            <span class="hljs-keyword">continue</span>;<br>        ans+=p[i].w;<br>        f[u]=v;<br>        tot++;<br>        <span class="hljs-keyword">if</span>(tot==n<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(tot==n<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><h4 id="单哈希"><a href="#单哈希" class="headerlink" title="单哈希"></a>单哈希</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> T=<span class="hljs-number">131</span>;<br>ull p[N],h[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(string s)</span></span>&#123;<br>    p[<span class="hljs-number">0</span>]=h[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=s.<span class="hljs-built_in">size</span>();i++)&#123;<br>        p[i]=p[i<span class="hljs-number">-1</span>]*T;<br>        h[i]=h[i<span class="hljs-number">-1</span>]*T+s[i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;a&#x27;</span><span class="hljs-number">+1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function">ull <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*p[r-l<span class="hljs-number">+1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="双哈希"><a href="#双哈希" class="headerlink" title="双哈希"></a>双哈希</h4><p>暂定</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p><strong>基础概念</strong></p><p>你有 $N$ 个物品和一个可以容纳 $M$ 个单位重量的袋子，每个物品的重量为 $W_i$ ，价值为 $C_i$ ，求在物品重量之和不超过 $M$ 时可获得的最大价值。</p><p><strong>延申含义</strong></p><p>（虽然是延伸，但是大部分延伸问题也都是属于正常背包的范畴之内）</p><p>在某些动态规划问题中，dp数组无法直接记录所有转移需要的信息，所以将一个信息存储在数组的一个维度中（如转换后二维数组的第二维下标）</p><h5 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h5><p><strong>定义</strong></p><p>即每个物品只能选一次或不选。</p><p><strong>代码模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=w[i];j--)<br>        f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-w[i]]+c[i]);<br></code></pre></td></tr></table></figure><h5 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h5><p><strong>定义</strong></p><p>每个物品可以选无数次</p><p><strong>代码模板</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=w[i];j&lt;=m;j++)<br>        f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-w[i]]+c[i]);<br></code></pre></td></tr></table></figure><h5 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h5><p><strong>定义</strong></p><p>每个物品可以选有限次（设第 $i$ 个物品可以选择的次数为 $v_i$ ）</p><p><strong>做法</strong></p><p>可以转化为01背包问题，或者可以同时转化为完全背包问题。</p><p>还可以进行二进制优化后计算01背包得到答案。</p><p><strong>代码模板</strong></p><ul><li>转换为01背包</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=w[i];j--)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=v[i];k&gt;=<span class="hljs-number">0</span>;k--)<br>            <span class="hljs-keyword">if</span>(j&gt;=k*w[i])<br>                f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-k*w[i]]+k*c[i]);<br></code></pre></td></tr></table></figure><ul><li>转换为01背包+完全背包（可降低部分时间复杂度）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(v[i]*w[i]&gt;m)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=w[i];j&lt;=m;j++)<br>            f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-w[i]]+c[i]);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=w[i];j--)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=v[i];k&gt;=<span class="hljs-number">0</span>;k--)<br>                <span class="hljs-keyword">if</span>(j&gt;=k*w[i])<br>                    f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-k*w[i]]+k*c[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码技巧"><a href="#代码技巧" class="headerlink" title="代码技巧"></a>代码技巧</h2><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>当需要存储的下标的值域过大（可能为$\lbrack -1 \times 10^9, 1 \times 10^9 \rbrack$）而真正需要的数据在可以接受范围内时，可以使用离散化。</p><p>假如有此下标：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-3</span><br>4<br>20<br></code></pre></td></tr></table></figure><p>可以离散化成：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>3<br></code></pre></td></tr></table></figure><p>这就是离散化，实现方式很多，一般采用<code>map</code>映射</p><h4 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h4><ul><li><a href="https://www.luogu.com.cn/problem/U221939">U221939 区间和 - 洛谷</a>（+树状数组&#x2F;线段树）</li></ul><h3 id="自动全排列"><a href="#自动全排列" class="headerlink" title="自动全排列"></a>自动全排列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>,a+n<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">do</span>&#123;<br>    <span class="hljs-comment">//sth...</span><br>&#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a<span class="hljs-number">+1</span>,a+n<span class="hljs-number">+1</span>));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>C++</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>庆祝建站完成！</title>
    <link href="/2025/09/30/%E5%BA%86%E7%A5%9D%E5%BB%BA%E7%AB%99%E5%AE%8C%E6%88%90/"/>
    <url>/2025/09/30/%E5%BA%86%E7%A5%9D%E5%BB%BA%E7%AB%99%E5%AE%8C%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>就在今天，这个非同一般的日子，我们的，伟大的博客上线了！</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>庆祝</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
